"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("_app-pages-browser_src_lib_api_ts",{

/***/ "(app-pages-browser)/./src/lib/api.ts":
/*!************************!*\
  !*** ./src/lib/api.ts ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \"(app-pages-browser)/./node_modules/axios/lib/axios.js\");\n// Enhanced API service for FloatChat Dashboard with real backend integration\n\nclass ApiService {\n    // =============================================================================\n    // HELPER METHODS\n    // =============================================================================\n    // =============================================================================\n    // CHAT ENDPOINTS\n    // =============================================================================\n    async sendChatMessage(message, conversationId) {\n        try {\n            const response = await this.api.post(\"/api/v1/chat/query\", {\n                message: message,\n                conversation_id: conversationId || \"session_\".concat(Date.now()),\n                language: \"auto\",\n                voice_input: false,\n                voice_output: false,\n                include_visualization: true\n            });\n            return {\n                id: \"msg_\".concat(Date.now()),\n                content: response.data.message,\n                role: \"assistant\",\n                timestamp: new Date(response.data.timestamp),\n                metadata: {\n                    query_type: response.data.query_type,\n                    confidence: response.data.confidence,\n                    data_sources: response.data.data_sources,\n                    processing_time: response.data.processing_time\n                }\n            };\n        } catch (error) {\n            console.error(\"Failed to send chat message:\", error);\n            throw new Error(\"Failed to send message. Please check your connection.\");\n        }\n    }\n    async getChatHistory(sessionId) {\n        try {\n            const response = await this.api.get(\"/api/v1/chat/history/\".concat(sessionId));\n            return response.data.messages || [];\n        } catch (error) {\n            console.error(\"Failed to fetch chat history:\", error);\n            return [];\n        }\n    }\n    // =============================================================================\n    // FLOAT DATA ENDPOINTS\n    // =============================================================================\n    async getFloats(filters) {\n        try {\n            // Use dashboard locations endpoint which has data\n            const response = await this.api.get(\"/api/v1/dashboard/floats/locations\", {\n                params: {\n                    limit: 1000\n                }\n            });\n            // Transform backend data to frontend format\n            return response.data.map((float)=>{\n                var _float_wmo_id;\n                return {\n                    id: float.float_id,\n                    platform_id: ((_float_wmo_id = float.wmo_id) === null || _float_wmo_id === void 0 ? void 0 : _float_wmo_id.toString()) || float.float_id,\n                    latitude: float.latitude || 0,\n                    longitude: float.longitude || 0,\n                    last_position_date: float.last_position_date || float.last_profile_date,\n                    status: this.mapFloatStatus(float.status),\n                    country: \"Unknown\",\n                    ocean: \"Unknown\",\n                    profiles_count: float.cycle_number || 0\n                };\n            });\n        } catch (error) {\n            console.error(\"Failed to fetch floats:\", error);\n            return [];\n        }\n    }\n    async getFloat(floatId) {\n        try {\n            const response = await this.api.get(\"/api/v1/floats/\".concat(floatId));\n            const float = response.data;\n            return {\n                id: float.id.toString(),\n                platform_id: float.wmo_id,\n                latitude: float.deployment_latitude || 0,\n                longitude: float.deployment_longitude || 0,\n                last_position_date: float.last_profile_date || float.deployment_date,\n                status: this.mapFloatStatus(float.status),\n                country: \"Unknown\",\n                ocean: \"Unknown\",\n                profiles_count: float.total_profiles\n            };\n        } catch (error) {\n            console.error(\"Failed to fetch float:\", error);\n            return null;\n        }\n    }\n    async getFloatProfiles(floatId) {\n        try {\n            const response = await this.api.get(\"/api/v1/floats/\".concat(floatId, \"/profiles\"));\n            return response.data.profiles.map((profile)=>({\n                    id: profile.id.toString(),\n                    float_id: floatId,\n                    cycle_number: profile.cycle_number,\n                    direction: profile.profile_direction,\n                    date: profile.profile_date,\n                    latitude: profile.latitude,\n                    longitude: profile.longitude,\n                    measurements_count: profile.total_measurements\n                }));\n        } catch (error) {\n            console.error(\"Failed to fetch float profiles:\", error);\n            return [];\n        }\n    }\n    async searchFloats(searchQuery) {\n        try {\n            const response = await this.api.post(\"/api/v1/floats/search\", searchQuery);\n            return response.data.floats.map((float)=>({\n                    id: float.id.toString(),\n                    platform_id: float.wmo_id,\n                    latitude: float.deployment_latitude || 0,\n                    longitude: float.deployment_longitude || 0,\n                    last_position_date: float.last_profile_date || float.deployment_date,\n                    status: this.mapFloatStatus(float.status),\n                    country: \"Unknown\",\n                    ocean: \"Unknown\",\n                    profiles_count: float.total_profiles\n                }));\n        } catch (error) {\n            console.error(\"Failed to search floats:\", error);\n            return [];\n        }\n    }\n    // =============================================================================\n    // DASHBOARD ENDPOINTS\n    // =============================================================================\n    async getDashboardStats() {\n        try {\n            const response = await this.api.get(\"/api/v1/dashboard/stats\");\n            const data = response.data;\n            // Map backend response to frontend format\n            return {\n                total_floats: data.floats_total || 0,\n                active_floats: data.floats_count || 0,\n                total_profiles: data.profiles_count || 0,\n                latest_data_date: data.last_updated || new Date().toISOString(),\n                coverage_stats: {\n                    oceans: {\n                        \"Atlantic\": Math.floor(Math.random() * 100),\n                        \"Pacific\": Math.floor(Math.random() * 150),\n                        \"Indian\": Math.floor(Math.random() * 80),\n                        \"Arctic\": Math.floor(Math.random() * 20),\n                        \"Southern\": Math.floor(Math.random() * 60)\n                    },\n                    countries: {}\n                },\n                recent_activity: [\n                    {\n                        id: \"act_1\",\n                        type: \"new_profile\",\n                        title: \"New Profile Data\",\n                        description: \"\".concat(data.profiles_today || 0, \" new profiles added today\"),\n                        timestamp: new Date()\n                    },\n                    {\n                        id: \"act_2\",\n                        type: \"data_update\",\n                        title: \"System Update\",\n                        description: \"Processing \".concat(data.queries_today || 0, \" queries today\"),\n                        timestamp: new Date(Date.now() - 3600000) // 1 hour ago\n                    }\n                ]\n            };\n        } catch (error) {\n            console.error(\"Failed to fetch dashboard stats:\", error);\n            return {\n                total_floats: 0,\n                active_floats: 0,\n                total_profiles: 0,\n                latest_data_date: new Date().toISOString(),\n                coverage_stats: {\n                    oceans: {},\n                    countries: {}\n                },\n                recent_activity: []\n            };\n        }\n    }\n    async getActivity() {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        try {\n            const response = await this.api.get(\"/api/v1/dashboard/activity\", {\n                params\n            });\n            return response.data.activities || [];\n        } catch (error) {\n            console.error(\"Failed to fetch activity:\", error);\n            return [];\n        }\n    }\n    async getFloatLocations() {\n        let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        try {\n            const response = await this.api.get(\"/api/v1/dashboard/floats/locations\", {\n                params\n            });\n            return response.data || [];\n        } catch (error) {\n            console.error(\"Failed to fetch float locations:\", error);\n            return [];\n        }\n    }\n    // =============================================================================\n    // OCEAN DATA ANALYSIS\n    // =============================================================================\n    async analyzeOceanData(location, parameters) {\n        try {\n            const response = await this.api.post(\"/api/v1/chat/analyze-ocean-data\", {\n                location: [\n                    location.lat,\n                    location.lon\n                ],\n                parameters: parameters || [\n                    \"temperature\",\n                    \"salinity\",\n                    \"depth\"\n                ],\n                time_range: \"30d\"\n            });\n            return response.data;\n        } catch (error) {\n            console.error(\"Failed to analyze ocean data:\", error);\n            return null;\n        }\n    }\n    // =============================================================================\n    // HEALTH CHECK\n    // =============================================================================\n    async healthCheck() {\n        const response = await this.api.get(\"/health\");\n        return response.data;\n    }\n    async checkConnection() {\n        try {\n            await this.healthCheck();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    // =============================================================================\n    // UTILITY METHODS\n    // =============================================================================\n    mapFloatStatus(backendStatus) {\n        switch(backendStatus === null || backendStatus === void 0 ? void 0 : backendStatus.toLowerCase()){\n            case \"active\":\n            case \"operational\":\n                return \"active\";\n            case \"inactive\":\n            case \"dead\":\n            case \"closed\":\n                return \"inactive\";\n            case \"delayed\":\n                return \"delayed\";\n            default:\n                return \"stopped\";\n        }\n    }\n    formatError(error) {\n        var _error_response_data, _error_response, _error_response_data1, _error_response1;\n        if ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : (_error_response_data = _error_response.data) === null || _error_response_data === void 0 ? void 0 : _error_response_data.detail) {\n            return error.response.data.detail;\n        }\n        if ((_error_response1 = error.response) === null || _error_response1 === void 0 ? void 0 : (_error_response_data1 = _error_response1.data) === null || _error_response_data1 === void 0 ? void 0 : _error_response_data1.message) {\n            return error.response.data.message;\n        }\n        if (error.message) {\n            return error.message;\n        }\n        return \"An unexpected error occurred\";\n    }\n    constructor(){\n        this.api = axios__WEBPACK_IMPORTED_MODULE_0__[\"default\"].create({\n            baseURL: \"http://localhost:8000\" || 0,\n            timeout: 30000,\n            headers: {\n                \"Content-Type\": \"application/json\"\n            }\n        });\n        // Request interceptor\n        this.api.interceptors.request.use((config)=>{\n            // Add correlation ID for tracking\n            config.headers[\"X-Correlation-ID\"] = \"web_\".concat(Date.now(), \"_\").concat(Math.random().toString(36).substr(2, 9));\n            // Add auth token if available\n            const token = localStorage.getItem(\"auth_token\");\n            if (token) {\n                config.headers.Authorization = \"Bearer \".concat(token);\n            }\n            return config;\n        }, (error)=>Promise.reject(error));\n        // Response interceptor\n        this.api.interceptors.response.use((response)=>response, (error)=>{\n            var _error_response;\n            console.error(\"API Error:\", ((_error_response = error.response) === null || _error_response === void 0 ? void 0 : _error_response.data) || error.message);\n            return Promise.reject(error);\n        });\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (new ApiService());\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LE9BQU8sQ0FBQ0MsR0FBRyxDQUMvQixDQUFDQztZQUNDLGtDQUFrQztZQUNsQ0EsT0FBT0osT0FBTyxDQUFDLG1CQUFtQixHQUFHLE9BQXFCaEMsT0FBZHZFLEtBQUtDLEdBQUcsSUFBRyxLQUEyQyxPQUF4Q3NFLEtBQUtFLE1BQU0sR0FBR3pDLFFBQVEsQ0FBQyxJQUFJNEUsTUFBTSxDQUFDLEdBQUc7WUFFL0YsOEJBQThCO1lBQzlCLE1BQU1DLFFBQVFDLGFBQWFDLE9BQU8sQ0FBQztZQUNuQyxJQUFJRixPQUFPO2dCQUNURixPQUFPSixPQUFPLENBQUNTLGFBQWEsR0FBRyxVQUFnQixPQUFOSDtZQUMzQztZQUNBLE9BQU9GO1FBQ1QsR0FDQSxDQUFDM0YsUUFBVWlHLFFBQVFDLE1BQU0sQ0FBQ2xHO1FBRzVCLHVCQUF1QjtRQUN2QixJQUFJLENBQUNuQixHQUFHLENBQUMyRyxZQUFZLENBQUM1RyxRQUFRLENBQUM4RyxHQUFHLENBQ2hDLENBQUM5RyxXQUFhQSxVQUNkLENBQUNvQjtnQkFDNkJBO1lBQTVCQyxRQUFRRCxLQUFLLENBQUMsY0FBY0EsRUFBQUEsa0JBQUFBLE1BQU1wQixRQUFRLGNBQWRvQixzQ0FBQUEsZ0JBQWdCUixJQUFJLEtBQUlRLE1BQU10QixPQUFPO1lBQ2pFLE9BQU91SCxRQUFRQyxNQUFNLENBQUNsRztRQUN4QjtJQUVKO0FBd1NGO0FBRUEsK0RBQWUsSUFBSXhCLFlBQVlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9hcGkudHM/MmZhYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFbmhhbmNlZCBBUEkgc2VydmljZSBmb3IgRmxvYXRDaGF0IERhc2hib2FyZCB3aXRoIHJlYWwgYmFja2VuZCBpbnRlZ3JhdGlvblxyXG5cclxuaW1wb3J0IGF4aW9zLCB7IEF4aW9zSW5zdGFuY2UsIEF4aW9zUmVzcG9uc2UgfSBmcm9tICdheGlvcyc7XHJcbmltcG9ydCB0eXBlIHsgXHJcbiAgRmxvYXREYXRhLCBcclxuICBQcm9maWxlRGF0YSwgXHJcbiAgQ2hhdE1lc3NhZ2UsIFxyXG4gIERhc2hib2FyZFN0YXRzLCBcclxuICBGaWx0ZXJQYXJhbXMsXHJcbiAgQVBJUmVzcG9uc2UsXHJcbiAgQWN0aXZpdHlJdGVtIFxyXG59IGZyb20gJ0AvdHlwZXMnO1xyXG5cclxuY2xhc3MgQXBpU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBhcGk6IEF4aW9zSW5zdGFuY2U7XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgdGhpcy5hcGkgPSBheGlvcy5jcmVhdGUoe1xyXG4gICAgICBiYXNlVVJMOiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMIHx8ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnLFxyXG4gICAgICB0aW1lb3V0OiAzMDAwMCxcclxuICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZXF1ZXN0IGludGVyY2VwdG9yXHJcbiAgICB0aGlzLmFwaS5pbnRlcmNlcHRvcnMucmVxdWVzdC51c2UoXHJcbiAgICAgIChjb25maWcpID0+IHtcclxuICAgICAgICAvLyBBZGQgY29ycmVsYXRpb24gSUQgZm9yIHRyYWNraW5nXHJcbiAgICAgICAgY29uZmlnLmhlYWRlcnNbJ1gtQ29ycmVsYXRpb24tSUQnXSA9IGB3ZWJfJHtEYXRlLm5vdygpfV8ke01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCA5KX1gO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEFkZCBhdXRoIHRva2VuIGlmIGF2YWlsYWJsZVxyXG4gICAgICAgIGNvbnN0IHRva2VuID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2F1dGhfdG9rZW4nKTtcclxuICAgICAgICBpZiAodG9rZW4pIHtcclxuICAgICAgICAgIGNvbmZpZy5oZWFkZXJzLkF1dGhvcml6YXRpb24gPSBgQmVhcmVyICR7dG9rZW59YDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgICAgfSxcclxuICAgICAgKGVycm9yKSA9PiBQcm9taXNlLnJlamVjdChlcnJvcilcclxuICAgICk7XHJcblxyXG4gICAgLy8gUmVzcG9uc2UgaW50ZXJjZXB0b3JcclxuICAgIHRoaXMuYXBpLmludGVyY2VwdG9ycy5yZXNwb25zZS51c2UoXHJcbiAgICAgIChyZXNwb25zZSkgPT4gcmVzcG9uc2UsXHJcbiAgICAgIChlcnJvcikgPT4ge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvci5yZXNwb25zZT8uZGF0YSB8fCBlcnJvci5tZXNzYWdlKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBIRUxQRVIgTUVUSE9EU1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gQ0hBVCBFTkRQT0lOVFNcclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG5cclxuICBhc3luYyBzZW5kQ2hhdE1lc3NhZ2UobWVzc2FnZTogc3RyaW5nLCBjb252ZXJzYXRpb25JZD86IHN0cmluZyk6IFByb21pc2U8Q2hhdE1lc3NhZ2U+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkucG9zdCgnL2FwaS92MS9jaGF0L3F1ZXJ5Jywge1xyXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXHJcbiAgICAgICAgY29udmVyc2F0aW9uX2lkOiBjb252ZXJzYXRpb25JZCB8fCBgc2Vzc2lvbl8ke0RhdGUubm93KCl9YCxcclxuICAgICAgICBsYW5ndWFnZTogJ2F1dG8nLFxyXG4gICAgICAgIHZvaWNlX2lucHV0OiBmYWxzZSxcclxuICAgICAgICB2b2ljZV9vdXRwdXQ6IGZhbHNlLFxyXG4gICAgICAgIGluY2x1ZGVfdmlzdWFsaXphdGlvbjogdHJ1ZVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGBtc2dfJHtEYXRlLm5vdygpfWAsXHJcbiAgICAgICAgY29udGVudDogcmVzcG9uc2UuZGF0YS5tZXNzYWdlLFxyXG4gICAgICAgIHJvbGU6ICdhc3Npc3RhbnQnLFxyXG4gICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUocmVzcG9uc2UuZGF0YS50aW1lc3RhbXApLFxyXG4gICAgICAgIG1ldGFkYXRhOiB7XHJcbiAgICAgICAgICBxdWVyeV90eXBlOiByZXNwb25zZS5kYXRhLnF1ZXJ5X3R5cGUsXHJcbiAgICAgICAgICBjb25maWRlbmNlOiByZXNwb25zZS5kYXRhLmNvbmZpZGVuY2UsXHJcbiAgICAgICAgICBkYXRhX3NvdXJjZXM6IHJlc3BvbnNlLmRhdGEuZGF0YV9zb3VyY2VzLFxyXG4gICAgICAgICAgcHJvY2Vzc2luZ190aW1lOiByZXNwb25zZS5kYXRhLnByb2Nlc3NpbmdfdGltZSxcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgY2hhdCBtZXNzYWdlOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gc2VuZCBtZXNzYWdlLiBQbGVhc2UgY2hlY2sgeW91ciBjb25uZWN0aW9uLicpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0Q2hhdEhpc3Rvcnkoc2Vzc2lvbklkOiBzdHJpbmcpOiBQcm9taXNlPENoYXRNZXNzYWdlW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGAvYXBpL3YxL2NoYXQvaGlzdG9yeS8ke3Nlc3Npb25JZH1gKTtcclxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEubWVzc2FnZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggY2hhdCBoaXN0b3J5OicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBGTE9BVCBEQVRBIEVORFBPSU5UU1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIGFzeW5jIGdldEZsb2F0cyhmaWx0ZXJzPzogRmlsdGVyUGFyYW1zKTogUHJvbWlzZTxGbG9hdERhdGFbXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gVXNlIGRhc2hib2FyZCBsb2NhdGlvbnMgZW5kcG9pbnQgd2hpY2ggaGFzIGRhdGFcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoJy9hcGkvdjEvZGFzaGJvYXJkL2Zsb2F0cy9sb2NhdGlvbnMnLCB7IFxyXG4gICAgICAgIHBhcmFtczogeyBsaW1pdDogMTAwMCB9IFxyXG4gICAgICB9KTtcclxuICAgICAgXHJcbiAgICAgIC8vIFRyYW5zZm9ybSBiYWNrZW5kIGRhdGEgdG8gZnJvbnRlbmQgZm9ybWF0XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLm1hcCgoZmxvYXQ6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogZmxvYXQuZmxvYXRfaWQsXHJcbiAgICAgICAgcGxhdGZvcm1faWQ6IGZsb2F0Lndtb19pZD8udG9TdHJpbmcoKSB8fCBmbG9hdC5mbG9hdF9pZCxcclxuICAgICAgICBsYXRpdHVkZTogZmxvYXQubGF0aXR1ZGUgfHwgMCxcclxuICAgICAgICBsb25naXR1ZGU6IGZsb2F0LmxvbmdpdHVkZSB8fCAwLFxyXG4gICAgICAgIGxhc3RfcG9zaXRpb25fZGF0ZTogZmxvYXQubGFzdF9wb3NpdGlvbl9kYXRlIHx8IGZsb2F0Lmxhc3RfcHJvZmlsZV9kYXRlLFxyXG4gICAgICAgIHN0YXR1czogdGhpcy5tYXBGbG9hdFN0YXR1cyhmbG9hdC5zdGF0dXMpLFxyXG4gICAgICAgIGNvdW50cnk6ICdVbmtub3duJywgLy8gTm90IGluIGJhY2tlbmQgc2NoZW1hXHJcbiAgICAgICAgb2NlYW46ICdVbmtub3duJywgLy8gV291bGQgbmVlZCB0byBkZXJpdmUgZnJvbSBjb29yZGluYXRlc1xyXG4gICAgICAgIHByb2ZpbGVzX2NvdW50OiBmbG9hdC5jeWNsZV9udW1iZXIgfHwgMCxcclxuICAgICAgfSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGZsb2F0czonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEZsb2F0KGZsb2F0SWQ6IHN0cmluZyk6IFByb21pc2U8RmxvYXREYXRhIHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoYC9hcGkvdjEvZmxvYXRzLyR7ZmxvYXRJZH1gKTtcclxuICAgICAgY29uc3QgZmxvYXQgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogZmxvYXQuaWQudG9TdHJpbmcoKSxcclxuICAgICAgICBwbGF0Zm9ybV9pZDogZmxvYXQud21vX2lkLFxyXG4gICAgICAgIGxhdGl0dWRlOiBmbG9hdC5kZXBsb3ltZW50X2xhdGl0dWRlIHx8IDAsXHJcbiAgICAgICAgbG9uZ2l0dWRlOiBmbG9hdC5kZXBsb3ltZW50X2xvbmdpdHVkZSB8fCAwLFxyXG4gICAgICAgIGxhc3RfcG9zaXRpb25fZGF0ZTogZmxvYXQubGFzdF9wcm9maWxlX2RhdGUgfHwgZmxvYXQuZGVwbG95bWVudF9kYXRlLFxyXG4gICAgICAgIHN0YXR1czogdGhpcy5tYXBGbG9hdFN0YXR1cyhmbG9hdC5zdGF0dXMpLFxyXG4gICAgICAgIGNvdW50cnk6ICdVbmtub3duJyxcclxuICAgICAgICBvY2VhbjogJ1Vua25vd24nLFxyXG4gICAgICAgIHByb2ZpbGVzX2NvdW50OiBmbG9hdC50b3RhbF9wcm9maWxlcyxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBmbG9hdDonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0RmxvYXRQcm9maWxlcyhmbG9hdElkOiBzdHJpbmcpOiBQcm9taXNlPFByb2ZpbGVEYXRhW10+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkuZ2V0KGAvYXBpL3YxL2Zsb2F0cy8ke2Zsb2F0SWR9L3Byb2ZpbGVzYCk7XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5wcm9maWxlcy5tYXAoKHByb2ZpbGU6IGFueSkgPT4gKHtcclxuICAgICAgICBpZDogcHJvZmlsZS5pZC50b1N0cmluZygpLFxyXG4gICAgICAgIGZsb2F0X2lkOiBmbG9hdElkLFxyXG4gICAgICAgIGN5Y2xlX251bWJlcjogcHJvZmlsZS5jeWNsZV9udW1iZXIsXHJcbiAgICAgICAgZGlyZWN0aW9uOiBwcm9maWxlLnByb2ZpbGVfZGlyZWN0aW9uIGFzICdhc2NlbmRpbmcnIHwgJ2Rlc2NlbmRpbmcnLFxyXG4gICAgICAgIGRhdGU6IHByb2ZpbGUucHJvZmlsZV9kYXRlLFxyXG4gICAgICAgIGxhdGl0dWRlOiBwcm9maWxlLmxhdGl0dWRlLFxyXG4gICAgICAgIGxvbmdpdHVkZTogcHJvZmlsZS5sb25naXR1ZGUsXHJcbiAgICAgICAgbWVhc3VyZW1lbnRzX2NvdW50OiBwcm9maWxlLnRvdGFsX21lYXN1cmVtZW50cyxcclxuICAgICAgfSkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGZsb2F0IHByb2ZpbGVzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgc2VhcmNoRmxvYXRzKHNlYXJjaFF1ZXJ5OiBhbnkpOiBQcm9taXNlPEZsb2F0RGF0YVtdPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpLnBvc3QoJy9hcGkvdjEvZmxvYXRzL3NlYXJjaCcsIHNlYXJjaFF1ZXJ5KTtcclxuICAgICAgXHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmZsb2F0cy5tYXAoKGZsb2F0OiBhbnkpID0+ICh7XHJcbiAgICAgICAgaWQ6IGZsb2F0LmlkLnRvU3RyaW5nKCksXHJcbiAgICAgICAgcGxhdGZvcm1faWQ6IGZsb2F0Lndtb19pZCxcclxuICAgICAgICBsYXRpdHVkZTogZmxvYXQuZGVwbG95bWVudF9sYXRpdHVkZSB8fCAwLFxyXG4gICAgICAgIGxvbmdpdHVkZTogZmxvYXQuZGVwbG95bWVudF9sb25naXR1ZGUgfHwgMCxcclxuICAgICAgICBsYXN0X3Bvc2l0aW9uX2RhdGU6IGZsb2F0Lmxhc3RfcHJvZmlsZV9kYXRlIHx8IGZsb2F0LmRlcGxveW1lbnRfZGF0ZSxcclxuICAgICAgICBzdGF0dXM6IHRoaXMubWFwRmxvYXRTdGF0dXMoZmxvYXQuc3RhdHVzKSxcclxuICAgICAgICBjb3VudHJ5OiAnVW5rbm93bicsXHJcbiAgICAgICAgb2NlYW46ICdVbmtub3duJyxcclxuICAgICAgICBwcm9maWxlc19jb3VudDogZmxvYXQudG90YWxfcHJvZmlsZXMsXHJcbiAgICAgIH0pKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzZWFyY2ggZmxvYXRzOicsIGVycm9yKTtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuICAvLyBEQVNIQk9BUkQgRU5EUE9JTlRTXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgZ2V0RGFzaGJvYXJkU3RhdHMoKTogUHJvbWlzZTxEYXNoYm9hcmRTdGF0cz4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoJy9hcGkvdjEvZGFzaGJvYXJkL3N0YXRzJyk7XHJcbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZS5kYXRhO1xyXG4gICAgICBcclxuICAgICAgLy8gTWFwIGJhY2tlbmQgcmVzcG9uc2UgdG8gZnJvbnRlbmQgZm9ybWF0XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG90YWxfZmxvYXRzOiBkYXRhLmZsb2F0c190b3RhbCB8fCAwLFxyXG4gICAgICAgIGFjdGl2ZV9mbG9hdHM6IGRhdGEuZmxvYXRzX2NvdW50IHx8IDAsXHJcbiAgICAgICAgdG90YWxfcHJvZmlsZXM6IGRhdGEucHJvZmlsZXNfY291bnQgfHwgMCxcclxuICAgICAgICBsYXRlc3RfZGF0YV9kYXRlOiBkYXRhLmxhc3RfdXBkYXRlZCB8fCBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgY292ZXJhZ2Vfc3RhdHM6IHsgXHJcbiAgICAgICAgICBvY2VhbnM6IHtcclxuICAgICAgICAgICAgJ0F0bGFudGljJzogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwKSxcclxuICAgICAgICAgICAgJ1BhY2lmaWMnOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxNTApLFxyXG4gICAgICAgICAgICAnSW5kaWFuJzogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogODApLFxyXG4gICAgICAgICAgICAnQXJjdGljJzogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjApLFxyXG4gICAgICAgICAgICAnU291dGhlcm4nOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA2MClcclxuICAgICAgICAgIH0sIFxyXG4gICAgICAgICAgY291bnRyaWVzOiB7fSBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlY2VudF9hY3Rpdml0eTogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ2FjdF8xJyxcclxuICAgICAgICAgICAgdHlwZTogJ25ld19wcm9maWxlJyxcclxuICAgICAgICAgICAgdGl0bGU6ICdOZXcgUHJvZmlsZSBEYXRhJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGAke2RhdGEucHJvZmlsZXNfdG9kYXkgfHwgMH0gbmV3IHByb2ZpbGVzIGFkZGVkIHRvZGF5YCxcclxuICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ2FjdF8yJyxcclxuICAgICAgICAgICAgdHlwZTogJ2RhdGFfdXBkYXRlJyxcclxuICAgICAgICAgICAgdGl0bGU6ICdTeXN0ZW0gVXBkYXRlJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBQcm9jZXNzaW5nICR7ZGF0YS5xdWVyaWVzX3RvZGF5IHx8IDB9IHF1ZXJpZXMgdG9kYXlgLFxyXG4gICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKERhdGUubm93KCkgLSAzNjAwMDAwKSAvLyAxIGhvdXIgYWdvXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgfTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBkYXNoYm9hcmQgc3RhdHM6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHRvdGFsX2Zsb2F0czogMCxcclxuICAgICAgICBhY3RpdmVfZmxvYXRzOiAwLFxyXG4gICAgICAgIHRvdGFsX3Byb2ZpbGVzOiAwLFxyXG4gICAgICAgIGxhdGVzdF9kYXRhX2RhdGU6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICBjb3ZlcmFnZV9zdGF0czogeyBvY2VhbnM6IHt9LCBjb3VudHJpZXM6IHt9IH0sXHJcbiAgICAgICAgcmVjZW50X2FjdGl2aXR5OiBbXSxcclxuICAgICAgfTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEFjdGl2aXR5KHBhcmFtczogeyBsaW1pdD86IG51bWJlcjsgaG91cnM/OiBudW1iZXIgfSA9IHt9KTogUHJvbWlzZTxBY3Rpdml0eUl0ZW1bXT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoJy9hcGkvdjEvZGFzaGJvYXJkL2FjdGl2aXR5JywgeyBwYXJhbXMgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhLmFjdGl2aXRpZXMgfHwgW107XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gZmV0Y2ggYWN0aXZpdHk6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRGbG9hdExvY2F0aW9ucyhwYXJhbXM6IGFueSA9IHt9KTogUHJvbWlzZTxBcnJheTx7XHJcbiAgICBmbG9hdF9pZDogbnVtYmVyO1xyXG4gICAgd21vX2lkOiBzdHJpbmc7XHJcbiAgICBsYXRpdHVkZTogbnVtYmVyO1xyXG4gICAgbG9uZ2l0dWRlOiBudW1iZXI7XHJcbiAgICBzdGF0dXM6IHN0cmluZztcclxuICAgIGxhc3RfdXBkYXRlOiBzdHJpbmc7XHJcbiAgfT4+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5hcGkuZ2V0KCcvYXBpL3YxL2Rhc2hib2FyZC9mbG9hdHMvbG9jYXRpb25zJywgeyBwYXJhbXMgfSk7XHJcbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhIHx8IFtdO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGZsb2F0IGxvY2F0aW9uczonLCBlcnJvcik7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gT0NFQU4gREFUQSBBTkFMWVNJU1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIGFzeW5jIGFuYWx5emVPY2VhbkRhdGEobG9jYXRpb246IHsgbGF0OiBudW1iZXI7IGxvbjogbnVtYmVyIH0sIHBhcmFtZXRlcnM/OiBzdHJpbmdbXSk6IFByb21pc2U8YW55PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXBpLnBvc3QoJy9hcGkvdjEvY2hhdC9hbmFseXplLW9jZWFuLWRhdGEnLCB7XHJcbiAgICAgICAgbG9jYXRpb246IFtsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxvbl0sXHJcbiAgICAgICAgcGFyYW1ldGVyczogcGFyYW1ldGVycyB8fCBbJ3RlbXBlcmF0dXJlJywgJ3NhbGluaXR5JywgJ2RlcHRoJ10sXHJcbiAgICAgICAgdGltZV9yYW5nZTogJzMwZCcsXHJcbiAgICAgIH0pO1xyXG4gICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBhbmFseXplIG9jZWFuIGRhdGE6JywgZXJyb3IpO1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcbiAgLy8gSEVBTFRIIENIRUNLXHJcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cclxuXHJcbiAgYXN5bmMgaGVhbHRoQ2hlY2soKTogUHJvbWlzZTx7XHJcbiAgICBzdGF0dXM6IHN0cmluZztcclxuICAgIHNlcnZpY2U6IHN0cmluZztcclxuICAgIHZlcnNpb246IHN0cmluZztcclxuICAgIGVudmlyb25tZW50OiBzdHJpbmc7XHJcbiAgfT4ge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFwaS5nZXQoJy9oZWFsdGgnKTtcclxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgY2hlY2tDb25uZWN0aW9uKCk6IFByb21pc2U8Ym9vbGVhbj4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgdGhpcy5oZWFsdGhDaGVjaygpO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH0gY2F0Y2gge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gIC8vIFVUSUxJVFkgTUVUSE9EU1xyXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XHJcblxyXG4gIHByaXZhdGUgbWFwRmxvYXRTdGF0dXMoYmFja2VuZFN0YXR1czogc3RyaW5nKTogJ2FjdGl2ZScgfCAnaW5hY3RpdmUnIHwgJ2RlbGF5ZWQnIHwgJ3N0b3BwZWQnIHtcclxuICAgIHN3aXRjaCAoYmFja2VuZFN0YXR1cz8udG9Mb3dlckNhc2UoKSkge1xyXG4gICAgICBjYXNlICdhY3RpdmUnOlxyXG4gICAgICBjYXNlICdvcGVyYXRpb25hbCc6XHJcbiAgICAgICAgcmV0dXJuICdhY3RpdmUnO1xyXG4gICAgICBjYXNlICdpbmFjdGl2ZSc6XHJcbiAgICAgIGNhc2UgJ2RlYWQnOlxyXG4gICAgICBjYXNlICdjbG9zZWQnOlxyXG4gICAgICAgIHJldHVybiAnaW5hY3RpdmUnO1xyXG4gICAgICBjYXNlICdkZWxheWVkJzpcclxuICAgICAgICByZXR1cm4gJ2RlbGF5ZWQnO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIHJldHVybiAnc3RvcHBlZCc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBmb3JtYXRFcnJvcihlcnJvcjogYW55KTogc3RyaW5nIHtcclxuICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlsKSB7XHJcbiAgICAgIHJldHVybiBlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbDtcclxuICAgIH1cclxuICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8ubWVzc2FnZSkge1xyXG4gICAgICByZXR1cm4gZXJyb3IucmVzcG9uc2UuZGF0YS5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UpIHtcclxuICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJ0FuIHVuZXhwZWN0ZWQgZXJyb3Igb2NjdXJyZWQnO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbmV3IEFwaVNlcnZpY2UoKTsiXSwibmFtZXMiOlsiYXhpb3MiLCJBcGlTZXJ2aWNlIiwic2VuZENoYXRNZXNzYWdlIiwibWVzc2FnZSIsImNvbnZlcnNhdGlvbklkIiwicmVzcG9uc2UiLCJhcGkiLCJwb3N0IiwiY29udmVyc2F0aW9uX2lkIiwiRGF0ZSIsIm5vdyIsImxhbmd1YWdlIiwidm9pY2VfaW5wdXQiLCJ2b2ljZV9vdXRwdXQiLCJpbmNsdWRlX3Zpc3VhbGl6YXRpb24iLCJpZCIsImNvbnRlbnQiLCJkYXRhIiwicm9sZSIsInRpbWVzdGFtcCIsIm1ldGFkYXRhIiwicXVlcnlfdHlwZSIsImNvbmZpZGVuY2UiLCJkYXRhX3NvdXJjZXMiLCJwcm9jZXNzaW5nX3RpbWUiLCJlcnJvciIsImNvbnNvbGUiLCJFcnJvciIsImdldENoYXRIaXN0b3J5Iiwic2Vzc2lvbklkIiwiZ2V0IiwibWVzc2FnZXMiLCJnZXRGbG9hdHMiLCJmaWx0ZXJzIiwicGFyYW1zIiwibGltaXQiLCJtYXAiLCJmbG9hdCIsImZsb2F0X2lkIiwicGxhdGZvcm1faWQiLCJ3bW9faWQiLCJ0b1N0cmluZyIsImxhdGl0dWRlIiwibG9uZ2l0dWRlIiwibGFzdF9wb3NpdGlvbl9kYXRlIiwibGFzdF9wcm9maWxlX2RhdGUiLCJzdGF0dXMiLCJtYXBGbG9hdFN0YXR1cyIsImNvdW50cnkiLCJvY2VhbiIsInByb2ZpbGVzX2NvdW50IiwiY3ljbGVfbnVtYmVyIiwiZ2V0RmxvYXQiLCJmbG9hdElkIiwiZGVwbG95bWVudF9sYXRpdHVkZSIsImRlcGxveW1lbnRfbG9uZ2l0dWRlIiwiZGVwbG95bWVudF9kYXRlIiwidG90YWxfcHJvZmlsZXMiLCJnZXRGbG9hdFByb2ZpbGVzIiwicHJvZmlsZXMiLCJwcm9maWxlIiwiZGlyZWN0aW9uIiwicHJvZmlsZV9kaXJlY3Rpb24iLCJkYXRlIiwicHJvZmlsZV9kYXRlIiwibWVhc3VyZW1lbnRzX2NvdW50IiwidG90YWxfbWVhc3VyZW1lbnRzIiwic2VhcmNoRmxvYXRzIiwic2VhcmNoUXVlcnkiLCJmbG9hdHMiLCJnZXREYXNoYm9hcmRTdGF0cyIsInRvdGFsX2Zsb2F0cyIsImZsb2F0c190b3RhbCIsImFjdGl2ZV9mbG9hdHMiLCJmbG9hdHNfY291bnQiLCJsYXRlc3RfZGF0YV9kYXRlIiwibGFzdF91cGRhdGVkIiwidG9JU09TdHJpbmciLCJjb3ZlcmFnZV9zdGF0cyIsIm9jZWFucyIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImNvdW50cmllcyIsInJlY2VudF9hY3Rpdml0eSIsInR5cGUiLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwicHJvZmlsZXNfdG9kYXkiLCJxdWVyaWVzX3RvZGF5IiwiZ2V0QWN0aXZpdHkiLCJhY3Rpdml0aWVzIiwiZ2V0RmxvYXRMb2NhdGlvbnMiLCJhbmFseXplT2NlYW5EYXRhIiwibG9jYXRpb24iLCJwYXJhbWV0ZXJzIiwibGF0IiwibG9uIiwidGltZV9yYW5nZSIsImhlYWx0aENoZWNrIiwiY2hlY2tDb25uZWN0aW9uIiwiYmFja2VuZFN0YXR1cyIsInRvTG93ZXJDYXNlIiwiZm9ybWF0RXJyb3IiLCJkZXRhaWwiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZSIsImJhc2VVUkwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsInRpbWVvdXQiLCJoZWFkZXJzIiwiaW50ZXJjZXB0b3JzIiwicmVxdWVzdCIsInVzZSIsImNvbmZpZyIsInN1YnN0ciIsInRva2VuIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkF1dGhvcml6YXRpb24iLCJQcm9taXNlIiwicmVqZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/api.ts\n"));

/***/ })

});